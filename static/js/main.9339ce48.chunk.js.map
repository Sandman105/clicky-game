{"version":3,"sources":["components/Container.js","components/Row.js","components/Column.js","components/Card.js","components/Jumbotron.js","components/Image.js","App.js","serviceWorker.js","index.js"],"names":["Container","props","className","fluid","children","Row","helper","Column","base","md","lg","xl","columnClassName","concat","Card","dark","header","Jumbtron","style","fontSize","fontWeight","score","highScore","Image","id","name","image","handleClickOnImage","src","alt","onClick","App","state","choices","clicked","randomize","array","i","length","j","Math","floor","random","resetGame","randomizedChoices","setState","includes","alert","prevState","checkHighScore","handleWin","this","console","log","Jumbotron","map","key","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.9339ce48.chunk.js","sourcesContent":["import React from 'react';\n\nconst Container = props => {\n  return (\n    <div className={`container${props.fluid ? '-fluid' : ''}`}>\n      {props.children}\n    </div>\n  );\n};\n\nexport default Container;\n","import React from 'react';\n\nconst Row = props => {\n  return (\n    <div className={props.helper ? `row ${props.helper}` : 'row'}>\n      {props.children}\n    </div>\n  );\n};\n\nexport default Row;\n","import React from 'react';\n\nconst Column = ({ base = 12, md, lg, xl, children }) => {\n  let columnClassName = `col-${base}`;\n\n  if (md) {\n    columnClassName = columnClassName.concat(` col-md-${md}`);\n  }\n\n  if (lg) {\n    columnClassName = columnClassName.concat(` col-lg-${lg}`);\n  }\n\n  if (xl) {\n    columnClassName = columnClassName.concat(` col-xl-${xl}`);\n  }\n\n  return <div className={columnClassName}>{children}</div>;\n};\n\nexport default Column;\n","import React from 'react';\n\nconst Card = props => {\n  return (\n    <div className={`card mt-2 ${props.dark ? 'bg-dark' : 'bg-light'}`}>\n      {props.header && (\n        <div\n          className={`card-header ${props.dark ? 'text-light' : 'text-dark'}`}>\n          {props.header}\n        </div>\n      )}\n      <div className=\"card-body\">{props.children}</div>\n    </div>\n  );\n};\n\nexport default Card;\n\n/* anything that is defined inside the Card component when it is used\n    will be placed where props.children is called\n\n    <Card>\n      <p>Hi this is inside the card body</p>\n    </Card>\n\n    by doing this we don't have to pass down props to the Image component we used in App.js\n\n    If we imported the image component in here App.js would look like this...\n\n    <Card \n      header={name} \n      id={id}\n      name={name}\n      image={image}\n      handleClickOnImage={this.handleClickOnImage} \n      dark\n    />\n\n    and this card component would look like this\n\n  <div className={`card mt-2 ${props.dark ? 'bg-dark' : 'bg-light'}`}>\n      {props.header && (\n        <div\n          className={`card-header ${props.dark ? 'text-light' : 'text-dark'}`}>\n          {props.header}\n        </div>\n      )}\n      <div className=\"card-body\">\n        <Image\n          id={props.id}\n          name={props.name}\n          image={props.image}\n          handleClickOnImage={props.handleClickOnImage}\n        />\n      </div>\n    </div>\n    \n    we would have to pass down props to the Card from App and then pass the relevant props to the Image component because it is being used inside the Card. In this case it makes the Card less reuseable.\n\n  */\n","import React from 'react';\n\nconst Jumbtron = props => {\n  return (\n    <div\n      className={`\n      jumbotron jumbotron-fluid p-2 text-center ${\n        props.dark ? 'bg-dark text-light' : 'bg-light text-dark'\n      } `}>\n      {/* TAKE STYLE OUT JUST TO MAKE A POINT */}\n      <h1 className=\"m-3\" style={{ fontSize: 30, fontWeight: 200 }}>\n        GOT Memory Game - The night is dark and full of terrors...\n      </h1>\n      <span className=\"m-3\" style={{ fontSize: 30 }}>\n        Score: {props.score}\n      </span>\n      <span className=\"m-3\" style={{ fontSize: 30 }}>\n        High Score: {props.highScore}\n      </span>\n    </div>\n  );\n};\n\nexport default Jumbtron;\n","import React from 'react';\n\nconst Image = ({ id, name, image, handleClickOnImage }) => {\n  return (\n    <img\n      src={image}\n      alt={name}\n      className=\"img-fluid w-100 h-50\"\n      onClick={() => handleClickOnImage(id)}\n    />\n  );\n};\n\nexport default Image;\n","import React, { Component } from 'react';\nimport Container from './components/Container';\nimport Row from './components/Row';\nimport Column from './components/Column';\nimport Card from './components/Card';\nimport Jumbotron from './components/Jumbotron';\nimport Image from './components/Image';\nimport choices from './choices.json';\n\nclass App extends Component {\n  state = {\n    choices,\n    clicked: [],\n    highScore: 0\n  };\n\n  componentDidMount() {\n    this.setState({ choices: this.randomize(this.state.choices) });\n  }\n\n  /*\n\n  Here is a JavaScript implementation of the Durstenfeld shuffle, a computer-optimized version of Fisher-Yates:\n\n/*\n * Randomize array element order in-place.\n * Using Durstenfeld shuffle algorithm.\n\nfunction shuffleArray(array) {\n  for (var i = array.length - 1; i > 0; i--) {\n      var j = Math.floor(Math.random() * (i + 1));\n      var temp = array[i];\n      array[i] = array[j];\n      array[j] = temp;\n  }\n}\nThe Fisher-Yates algorithm works by picking one random element for each original array element, and then excluding it from the next draw. Just like randomly picking from a deck of cards.\n\nThis exclusion is done in a clever way (invented by Durstenfeld for use by computers) by swapping the picked element with the current element, and then picking the next random element from the remainder. For optimal efficiency, the loop runs backwards so that the random pick is simplified (it can always start at 0), and it skips the last element because there are no other choices anymore.\n\nThe running time of this algorithm is O(n). Note that the shuffle is done in-place. So if you do not want to modify the original array, make a copy of it first with .slice(0).\n\nUpdating to ES6 / ECMAScript 2015\nThe new ES6 allows us to assign two variables at once. This is especially handy when we want to swap the values of two variables, as we can do it in one line of code. Here is a shorter form of the same function, using this feature.\n\nfunction shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n  }\n}\n*/\n\n  randomize = array => {\n    for (let i = array.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [array[i], array[j]] = [array[j], array[i]];\n    }\n\n    return array;\n  };\n\n  // resetGame but not the high score\n\n  resetGame = () => {\n    const randomizedChoices = this.randomize(this.state.choices);\n\n    this.setState({\n      clicked: [],\n      choices: randomizedChoices\n    });\n  };\n\n  // handle click on image function\n\n  handleClickOnImage = id => {\n    // this is loss condition\n    if (this.state.clicked.includes(id)) {\n      alert('you lost');\n      this.resetGame();\n    } else {\n      // if they haven't clicked the image yet...\n      // we add the id to clicked array\n      // clicked: [0, 4, 2, 9]\n      // clicked: [0, 4, 2, 9, 3]\n      // first we setState of the clicked array and randomize our choices but after don't we need to check high score and win?\n      // What would happen if we did this?\n      // this.setState(prevState => ({\n      //   clicked: [...prevState.clicked, id],\n      //   choices: this.randomize(this.state.choices)\n      // }));\n      // this.checkHighScore();\n      // this.handleWin();\n      // this.setState is asynchronous and in this case checking the high score and the win rely on the state above, but it doesn't happen in that order even though we wrote it that way.\n      // this.setState takes an optional callack function and we can use that to run those checks AFTER we set the state of clicked and choices.\n      this.setState(\n        prevState => ({\n          clicked: [...prevState.clicked, id],\n          choices: this.randomize(this.state.choices)\n        }),\n        () => {\n          this.checkHighScore();\n          this.handleWin();\n        }\n      );\n    }\n  };\n\n  // check high score\n\n  checkHighScore = () => {\n    if (this.state.clicked.length > this.state.highScore) {\n      this.setState({ highScore: this.state.clicked.length });\n    }\n  };\n\n  // handle win function\n\n  handleWin = () => {\n    if (this.state.clicked.length === this.state.choices.length) {\n      alert('You won!');\n      this.resetGame();\n    }\n  };\n\n  render() {\n    // always console.log state in the render it will give you the freshest state. or use React Dev Tools.\n    console.log(this.state);\n    // don't have to write this.state over and over if we destructure here\n    const { clicked, choices, highScore } = this.state;\n    return (\n      <Container>\n        <Jumbotron score={clicked.length} highScore={highScore} dark />\n        <Row helper={`justify-content-center`}>\n          {choices.map(({ id, name, image }) => {\n            return (\n              <Column key={id} md={2}>\n                <Card header={name} dark>\n                  <Image\n                    id={id}\n                    name={name}\n                    image={image}\n                    handleClickOnImage={this.handleClickOnImage}\n                  />\n                </Card>\n              </Column>\n            );\n          })}\n        </Row>\n      </Container>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}